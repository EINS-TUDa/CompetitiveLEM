*******************************************************************************
* @author: julia.barbosa@eins.tu-darmstadt.de
********************************************************************************

* -------------------------------------------------------
* -- External Inputs --
* ---------------------------------------------------------
Sets
a  Agents
c  Commodities
t  Timesteps
p(a,c,c)  Processes



* -- Param Sets --
ParamSetSocial 
/
D0 
elasticity 
/


ParamSetAgentCommodity Agent Parameters
/
maxGen
strCap
strEff
bindedGenFactor
wasteCost
costGen
hasStorage
strPower
isCoupled
availbilityGiven
/

ParamSetAgentCommodityTime Agent Parameters (time dependent)
/
minLoad
maxLoad
availability
/

ParamSetProcess
/
pEff
pmaxPower
/

ParamSetSLR
/
hasSLR
maxRegPrice
/

;


$GDXIN mcp_input.gdx
$LOAD a c t p
$GDXIN


alias(c,ci,co);

* --  Parameters --
Parameters
ParamSocial(c,t, ParamSetSocial) Social Parameters (Commodity time  dependent)

ParamAC(a,c, ParamSetAgentCommodity)  Agent Parameters (Agent commodity dependent)

ParamACT(a,c,t, ParamSetAgentCommodityTime)  Agent Parameters (Agent commodity dependent time dependent)

ParamAP(a,ci,co, ParamSetProcess)

ParamSLR(c, ParamSetSLR)

validAC(a,c)    # Flag True if  commodity is valid for that agent
validWaste(a,c) # Flag True if agent can waste commodity c
;


$GDXIN mcp_input.gdx
$LOAD ParamSocial ParamAC ParamAP ParamACT  ParamSLR validAC validWaste
$GDXIN


* -- Derived and Parameters --
parameter
dt
validP(a,ci,co)

;
dt = 1;

loop(p(a,ci,co),
    validP(a,ci,co) = 1;
);



* -- Variables ---
Variables
Price

*wf Social Welfare
*cwf(c) Consumer welfare
 
D(c,t) Demand of commodity c at time t
* Primary Variables
Pm(a,c,t) Commodity c purchased by agent a at time t

* Free Dual Variables
dl_AgentPowerBalance(a,c,t)
dl_CoupledGeneration(a,t)
dl_PtConversion(a,ci,co,t)

dl_StorageEnergyBalance(a,c,t)

;

Positive Variables

*TotalCost(a) Total cost of agent a
Pr(c,t) Power provide by the regulator agent
Pg(a,c,t) Commodity c generated by the agent a at time t
Pd(a,c,t) Commodity c demanded by agent a at time t

Pw(a,c,t) Waste energy from coupled generation processes

Pt_in(a,ci,co,t) Power consumed by transformation process p at time t by agent a
Pt_out(a,ci,co,t) Power supplied by transformation process p at time t by agent a

Ps_d(a, c, t) Commodity c supplied by the agent a storage at time t
Ps_c(a, c, t) Commodity c consued by the agent to charge storage at time t
Es(a, c, t) Commodity c stored by the agent a at time t


* Regulation

*dm_PrUP(c,t)
*dm_PrlB(c,t)

* Positive Dual Variables
dm_PgUP(a,c,t)
dm_PdUP(a,c,t)
dm_PtOutUP(a,ci,co,t)

dm_PsCUP(a,c,t)
dm_PsDUP(a,c,t)
dm_EsUP(a,c,t)

;
* -------------------------------------------------------
Equations
EPrice_Eq
* - Primal Feasibility -
* -- Power Balance Eqs
PowerBalance_Eq(c,t)
AgentPowerBalance_Eq(a,c,t)


* -- Up Limits Eqs
PgUpper_Eq(a,c,t)
PdUpper_Eq(a,c,t)


* Coupled Generation Equations
CoupledCondition_Eq(a,t)

* Storage Equation
PsCUpper_Eq(a,c,t)
PsDUpper_Eq(a,c,t)
EsUpper_Eq(a,c,t)
StrEnergyBalance_Eq(a,c,t)

* Converion Processes
PtConversion_Eq(a,ci,co,t)
PtUpper_Eq(a,ci,co,t)

*Regulation
PriceCap_Eq(c,t)


* - Stationarity -
Pg_Lag(a,c,t)
Pd_Lag(a,c,t)
Pm_Lag(a,c,t)

PtIn_Lag(a,ci,co,t)
PtOut_Lag(a,ci,co,t)

PsD_Lag(a,c,t)
PsC_Lag(a,c,t)
Es_Lag(a,c,t)

Pw_Lag(a,c,t)

;

EPrice_Eq(c,t) ..
Price(c,t) =g= ParamSocial(c,t, "elasticity")*(ParamSocial(c,t,"D0") -D(c,t));

* - Primal Feasibility
* -- Power Balance Equations --
PowerBalance_Eq(c,t)..
 sum(a$validAC(a,c), Pm(a,c,t)) + Pr(c,t)$ParamSLR(c, "hasSLR") =e= D(c,t)
;


AgentPowerBalance_Eq(a,c,t) $ validAC(a,c) .. 
Pm(a,c,t) =e= Pg(a,c,t) - Pd(a,c,t)
    + (sum(p(a,ci,c)$validP(a,ci,c),Pt_out(a,ci,c,t)) - sum(p(a,c,co)$validP(a,c,co),Pt_in(a,c,co,t)))
    + (Ps_d(a,c,t)- Ps_c(a,c,t))$ParamAC(a,c,"hasStorage")      
;


* -- Power limits --
PgUpper_Eq(a,c,t)$(validAC(a,c))  ..
-Pg(a,c,t) =g= -ParamAC(a,c,"maxGen")$(not ParamAC(a,c,"availbilityGiven"))
               -(ParamAC(a,c,"maxGen")*ParamACT(a,c,t,"Availability"))$(ParamAC(a,c,"availbilityGiven"))             
;


* TODO: Make param for max demand
PdUpper_Eq(a,c,t)$validAC(a,c)..
-Pd(a,c,t) =g= -ParamACT(a,c,t,"maxLoad");


* -- Coupled Generation --
CoupledCondition_Eq(a,t) ..
    sum(c$(validAC(a,c) and not validWaste(a,c)), ParamAC(a,c,"bindedGenFactor")*Pg(a,c,t))
    + sum(c$(validAC(a,c) and validWaste(a,c)), ParamAC(a,c,"bindedGenFactor")*(Pg(a,c,t) + Pw(a,c,t)))  =e= 0;


* -- Storage Equations --
PsCUpper_Eq(a,c,t)$(validAC(a,c) and ParamAC(a,c,"hasStorage")) ..
    -Ps_c(a,c,t) + ParamAC(a,c,"strPower") =g= 0;
 
PsDUpper_Eq(a,c,t)$( validAC(a,c) and ParamAC(a,c,"hasStorage"))..
    -Ps_d(a,c,t) + ParamAC(a,c,"strPower") =g=0 ;

EsUpper_Eq(a,c,t)$(validAC(a,c)and ParamAC(a,c,"hasStorage"))..
    - Es(a,c,t) + ParamAC(a,c,"strCap") =g= 0;

StrEnergyBalance_Eq(a,c,t)$(validAC(a,c) and ParamAC(a,c,"hasStorage"))..
Es(a,c,t) =e= Es(a,c,t--1)
    + Ps_c(a,c,t)*ParamAC(a,c,"strEff") - Ps_d(a,c,t)
;


* -- Conversion Process eqs --
PtConversion_Eq(p(a,ci,co),t) $ validP(a,ci,co) ..
Pt_out(a, ci, co, t) - Pt_in(a,ci,co,t) * ParamAP(a,ci,co,"pEff") =e= 0;

PtUpper_Eq(p(a,ci,co),t)$ validP(a,ci,co)..
-Pt_out(a, ci, co, t) =g= -ParamAP(a,ci,co,"pmaxPower");

* -- Regualator --
PriceCap_Eq(c,t)$ParamSLR(c, "hasSLR")..
ParamSLR(c, "maxRegPrice") - Price(c,t)  =g=0
;


* - Stationarity -
Pg_Lag(a,c,t)$validAC(a,c)..
    ParamAC(a,c,"costGen") - dl_AgentPowerBalance(a,c,t) + dm_PgUP(a,c,t) + 
    (dl_CoupledGeneration(a,t)*ParamAC(a,c,"bindedGenFactor")$ParamAC(a,c,"bindedGenFactor"))
    =e= 0
;
*    
Pd_Lag(a,c,t)$validAC(a,c) ..
    dl_AgentPowerBalance(a,c,t) + dm_PdUP(a,c,t) =e= 0
;
Pm_Lag(a,c,t)$validAC(a,c) ..
    -Price(c,t) + ParamSocial(c,t,"Elasticity")*Pm(a,c,t)  + dl_AgentPowerBalance(a,c,t) =e= 0
;

PtIn_Lag(a,ci,co,t)$ validP(a,ci,co) ..
dl_AgentPowerBalance(a,ci,t) - dl_PtConversion(a,ci,co,t) * ParamAP(a,ci,co, "pEff") =e= 0
;
PtOut_Lag(a,ci,co,t)$validP(a,ci,co)..
- dl_AgentPowerBalance(a,co,t) + dl_PtConversion(a,ci,co,t) + dm_PtOutUP(a,ci,co,t) =e= 0
;

* Storage
PsD_Lag(a,c,t)$(validAC(a,c) and ParamAC(a,c,"hasStorage")) ..
-dl_AgentPowerBalance(a,c,t) + dl_StorageEnergyBalance(a,c,t)*dt + dm_PsDUP(a,c,t) =e= 0
;

PsC_Lag(a,c,t)$(validAC(a,c) and ParamAC(a,c,"hasStorage"))..
dl_AgentPowerBalance(a,c,t) - dl_StorageEnergyBalance(a,c,t)*ParamAC(a,c,"strEff")*dt + dm_PsCUP(a,c,t) =e= 0
;

Es_Lag(a,c,t)$(validAC(a,c) and ParamAC(a,c,"hasStorage"))..
dl_StorageEnergyBalance(a,c,t) - dl_StorageEnergyBalance(a,c,t+1) + dm_EsUP(a,c,t) =e= 0
;

Pw_Lag(a,c,t)$ validWaste(a,c) ..
ParamAC(a,c,"wasteCost") + dl_CoupledGeneration(a,t) =e= 0
;

*RegCost_Eq
*Pcap_Eq.dvPrice
*PregII.Pr

Model oligop /

PriceCap_Eq.Pr
EPrice_Eq.Price


PowerBalance_Eq.D,

Pg_Lag.Pg,
Pd_Lag.Pd,
Pm_Lag.Pm,
PtOut_Lag.Pt_out,
PtIn_Lag.Pt_in,
PsD_Lag.Ps_d
PsC_Lag.Ps_c
Es_Lag.Es
Pw_Lag.Pw


CoupledCondition_Eq,

PtConversion_Eq
AgentPowerBalance_Eq.dl_AgentPowerBalance,
StrEnergyBalance_Eq.dl_StorageEnergyBalance

PgUpper_Eq.dm_PgUP,
PdUpper_Eq.dm_PdUP,
PtUpper_Eq.dm_PtOutUP
PsCUpper_Eq.dm_PsCUP,
PsDUpper_Eq.dm_PsDUP,
EsUpper_Eq.dm_EsUP,


/
*Pcap_Eq.Pr
;
option mcp = PATH;
option limrow = 100;
solve oligop using mcp;
*solve oligop using mpec minimizing RegCost;
* -- Post Processing --


Parameters
energyPrice(c,t)
ProdSur(a)
ConSur(c)
;


energyPrice(c,t) = ParamSocial(c,t,"Elasticity")*(ParamSocial(c,t,"D0") - D.l(c,t));

ProdSur(a) = sum(c $ validAC(a,c),sum(t, Pm.l(a,c,t)*energyPrice(c,t)
            - Pg.l(a,c,t)*ParamAC(a,c,"costGen")
            -Pw.l(a,c,t)*ParamAC(a,c,"wasteCost")$validWaste(a,c)
            ));

* ConSur(c) = sum(t, ParamSocial(c,t,"elasticity")*(0.5*D.l(c,t)*D.l(c,t)));


ConSur(c) = sum(t, ParamSocial(c,t,"elasticity")*(ParamSocial(c,t,"D0")*D.l(c,t) - 0.5*D.l(c,t)*D.l(c,t))
-energyPrice(c,t)*D.l(c,t) );